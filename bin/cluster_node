#!/usr/bin/env node

/* jslint node: true, esnext: true */

'use strict';

const os = require('os'),
  fs = require('fs'),
  path = require('path'),
  commander = require('commander'),
  ksm = require('kronos-service-manager'),
  ee = require('expression-expander'),
  systemdSocket = require('systemd-socket'),
  rebirth = require('rebirth'),
  glob = require('glob'),
  createGrammar = require('pratt-parser').createGrammar;

require('pkginfo')(module, 'version');

let logLevel;

const flowFileNames = [];
const values = [];

commander
  .version(module.exports.version)
  .description('run cluster node')
  .option('-f, --flow <file>', 'flow to be registered', name => flowFileNames.push(name))
  .option('-s, --start', 'start flow after registering')
  .option('-c, --config <file>', 'use config from file')
  .option('-d, --define <service:key=value>', 'define service value', value => values.push(value))
  .option('-d, --debug', 'enable debugging')
  .option('-t, --trace', 'enable tracing')
  .parse(process.argv);

if (commander.debug) {
  logLevel = 'debug';
} else if (commander.trace) {
  logLevel = 'trace';
}

function createValue(value) {
  return Object.create(null, {
    value: {
      value: value
    }
  });
}

const cfg = commander.config ? new Promise((fullfill, reject) => {
  fs.readFile(commander.config, (err, data) => {
    if (err) reject(err);
    else {
      const functions = {
        file: args => createValue(fs.readFileSync(path.resolve(path.dirname(commander.config), args[0].value))),
        directory: args => createValue(path.resolve(path.dirname(commander.config), args[0].value))
      };
      const g = createGrammar({
        terminals: {
          number: {},
          identifier: {}
        },
        prefix: {
          '(': {
            precedence: 80,
            led(grammar, left) {
              if (left.type === 'identifier') {
                const f = functions[left.value];
                if (f === undefined) {
                  throw new Error(`Unknown function: ${left.value}`);
                }

                const args = [];

                if (grammar.token.value !== ')') {
                  while (true) {
                    args.push(grammar.expression(0));

                    if (grammar.token.value !== ',') {
                      break;
                    }
                    grammar.advance(',');
                  }
                }

                grammar.advance(')');

                return f(args);
              } else {
                const e = grammar.expression(0);
                grammar.advance(')');
                return e;
              }
            }
          }
        },
        infix: {
          ',': {},
          ')': {},
          '+': {
            precedence: 50,
            combine: (left, right) => createValue(left.value + right.value)
          },
          '-': {
            precedence: 50,
            combine: (left, right) => createValue(left.value - right.value)
          },
          '*': {
            precedence: 60,
            combine: (left, right) => createValue(left.value * right.value)
          },
          '/': {
            precedence: 60,
            combine: (left, right) => createValue(left.value / right.value)
          }
        }
      });

      const ctx = ee.createContext({
        evaluate: (expression, context) => g.parse(expression).value
      });
      fullfill(ctx.expand(JSON.parse(data)));
    }
  });
}) : Promise.resolve([{
  name: 'kronos'
}, {
  name: 'koa-admin',
  port: 10000
}, {
  name: 'registry', // consul
  checkInterval: '60s'
}]);

process.on('SIGHUP', () => rebirth());

function pglob(path, options) {
  return new Promise((fullfull, reject) => {
    glob(path, options, (err, files) => {
      if (err) {
        reject(err);
      } else {
        fullfull(files);
      }
    });
  });
}

function kronosModules() {
  return pglob(path.join(__dirname, '..', 'node_modules/*/package.json'), {}).then(files => {
    const modules = [];
    return Promise.all(files.map(file =>
      new Promise((fullfill, reject) => {
        fs.readFile(file, (err, data) => {
          if (err) {
            reject(`loading ${file}: ${err}`);
            return;
          }
          try {
            const p = JSON.parse(data);

            if (p.keywords) {
              if (p.keywords.find(k => k === 'kronos-step' || k ===
                  'kronos-service' || k ===
                  'kronos-interceptor')) {
                try {
                  modules.push(require(p.name));
                  fullfill();
                  return;
                } catch (e) {
                  reject(`${file}: ${p.name} ${e}`);
                }
              }
            }
          } catch (e) {
            reject(e);
          }

          fullfill();
        });
      })
    )).then(results => modules);
  });
}

Promise.all([kronosModules(), cfg]).then(results => {
  const modules = results[0];
  const cfg = results[1];

  values.forEach(value => {
    const m = value.match(/^([^:]+):([^=]+)=(.*)/);
    if (m) {
      let slot = cfg.find(c => c.name === m[1]);
      if (slot) {
        slot[m[2]] = m[3];
      } else {
        cfg.push({
          name: m[1],
          [m[2]]: m[3]
        });
      }
    } else {
      console.log(`no service:key=value ${value}`);
    }
  });

  if (logLevel !== undefined) {
    cfg.forEach(c => c.logLevel = logLevel);
  }

  const sds = systemdSocket();
  if (sds) {
    cfg[1 /* TODO admin */ ].port = sds;
  }

  ksm.manager(cfg, modules).then(manager => {
    if (logLevel !== undefined) {
      Object.keys(manager.services).forEach(sn => manager.services[sn].logLevel = logLevel);
    }

    process.on('uncaughtException', err => manager.error(err));
    process.on('unhandledRejection', reason => manager.error(reason));
    process.on('SIGINT', () => manager.stop().then(() => process.exit()));
    process.title = manager.id;

    flowFileNames.forEach(name => {
      manager.loadFlowFromFile(name).then(flow => {
        manager.info(`Flow declared: ${flow}`);
        if (commander.start) {
          manager.info(`Starting ... ${flow}`);
          flow.start().then(() => manager.info(`Flow started: ${flow}`)).catch(error =>
            manager.error(
              `Flow started failed: ${error}`));
        }
      }).catch(error => manager.error(`Flow initialization failed: ${error}`));
    });
  });
}).catch(console.log);

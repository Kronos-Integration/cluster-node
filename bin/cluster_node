#!/usr/bin/env node

/* jslint node: true, esnext: true */

'use strict';

const os = require('os'),
  fs = require('fs'),
  path = require('path'),
  commander = require('commander'),
  ksm = require('kronos-service-manager'),
  ee = require('expression-expander'),
  systemdSocket = require('systemd-socket'),
  rebirth = require('rebirth'),
  glob = require('glob'),
  address = require('network-address'),
  createGrammar = require('pratt-parser').createGrammar;

require('pkginfo')(module, 'version');

let logLevel;

const flowFileNames = [];
const values = [];

commander
  .version(module.exports.version)
  .description('run cluster node')
  .option('-f, --flow <file>', 'flow to be registered', name => flowFileNames.push(name))
  .option('-s, --start', 'start flow after registering')
  .option('-c, --config <file>', 'use config from file')
  .option('-d, --define <service:key=value> or <key=value>', 'define (service) value', value => values.push(value))
  .option('-d, --debug', 'enable debugging')
  .option('-t, --trace', 'enable tracing')
  .parse(process.argv);

if (commander.debug) {
  logLevel = 'debug';
} else if (commander.trace) {
  logLevel = 'trace';
}

const cfg = (commander.config ? new Promise((fullfill, reject) => {
  fs.readFile(commander.config, (err, data) => {
    if (err) reject(err);
    else
      fullfill(JSON.parse(data));
  });
}) : Promise.resolve({
  services: [{
    name: 'kronos'
  }, {
    name: 'koa-admin',
    port: 10000
  }, {
    name: 'registry', // consul
    checkInterval: '60s'
  }]
})).then(config => expand(config));

process.on('SIGHUP', () => rebirth());

function pglob(path, options) {
  return new Promise((fullfull, reject) => {
    glob(path, options, (err, files) => {
      if (err) {
        reject(err);
      } else {
        fullfull(files);
      }
    });
  });
}

function kronosModules() {
  return pglob(path.join(__dirname, '..', 'node_modules/*/package.json'), {}).then(files => {
    const modules = [];
    return Promise.all(files.map(file =>
      new Promise((fullfill, reject) => {
        fs.readFile(file, (err, data) => {
          if (err) {
            reject(`loading ${file}: ${err}`);
            return;
          }
          try {
            const p = JSON.parse(data);

            if (p.keywords) {
              if (p.keywords.find(k =>
                  k === 'kronos-step' || k === 'kronos-service' || k === 'kronos-interceptor')) {
                try {
                  modules.push(require(p.name));
                  fullfill();
                  return;
                } catch (e) {
                  reject(`${file}: ${p.name} ${e}`);
                }
              }
            }
          } catch (e) {
            reject(e);
          }

          fullfill();
        });
      })
    )).then(results => modules);
  });
}

Promise.all([kronosModules(), cfg]).then(results => {
  const modules = results[0];
  const cfg = results[1];

  if (logLevel !== undefined) {
    cfg.services.forEach(c => c.logLevel = logLevel);
  }

  const sds = systemdSocket();
  if (sds) {
    const as = cfg.services.find(s => s.name === 'koa-admin');
    if (as !== undefined) {
      as.port = sds;
    }
  }

  ksm.manager(cfg.services, modules).then(manager => {
    if (logLevel !== undefined) {
      Object.keys(manager.services).forEach(sn => manager.services[sn].logLevel = logLevel);
    }

    process.on('uncaughtException', err => manager.error(err));
    process.on('unhandledRejection', reason => manager.error(reason));
    process.on('SIGINT', () => {
      try {
        manager.stop().then(() => process.exit());
      } catch (e) {
        console.error(e);
        process.exit();
      }
    });

    process.title = manager.id;

    flowFileNames.forEach(name => {
      manager.loadFlowFromFile(name).then(flow => {
        manager.info(`Flow declared: ${flow}`);
        if (commander.start) {
          manager.info(`Starting ... ${flow}`);
          flow.start().then(() => manager.info(`Flow started: ${flow}`)).catch(error =>
            manager.error(
              `Flow started failed: ${error}`));
        }
      }).catch(error => manager.error(`Flow initialization failed: ${error}`));
    });
  });
}).catch(console.error);


function createValue(value) {
  return Object.create(null, {
    value: {
      value: value
    }
  });
}

function expand(config) {

  values.forEach(value => {
    const m = value.match(/^([a-zA-Z_][a-zA-Z_0-9]*):([a-zA-Z_][a-zA-Z_0-9]*)=(.*)/);
    if (m) {
      let slot = config.services.find(c => c.name === m[1]);
      if (slot) {
        slot[m[2]] = m[3];
      } else {
        config.services.push({
          name: m[1],
          [m[2]]: m[3]
        });
      }
    } else {
      const m = value.match(/^([a-zA-Z_][a-zA-Z_0-9]*)=(.*)/);
      if (m) {
        config.properties[m[1]] = m[2];
      } else
        console.error(`neither service:key=value nor key=value : ${value}`);
    }
  });

  const constants = {
    configDirectory: path.dirname(commander.config),
    networkAddress: address()
  };

  const functions = {
    file: args => createValue(fs.readFileSync(path.resolve(path.dirname(commander.config), args[0].value))),
    directory: args => createValue(path.resolve(path.dirname(commander.config), args[0].value)),
    include: args => {
      const v = createValue(JSON.parse(fs.readFileSync(path.resolve(path.dirname(commander.config), args[0].value))));
      return v;
    },
    // string functions
    number: args => {
      const v = args[0].value;
      return createValue(parseFloat(v) === v ? v : parseFloat(v.replace(/[a-z]+/, '')));
    },
    substring: args => createValue(args[0].value.substring(args[1].value, args[2].value)),
    replace: args => createValue(args[0].value.replace(args[1].value, args[2].value)),
    toUpperCase: args => createValue(args[0].value.toUpperCase()),
    toLowerCase: args => createValue(args[0].value.toLowerCase())
  };
  const g = createGrammar({
    identifier(value, properties, context) {
        const f = functions[value];
        if (f) {
          properties.type.value = 'function';
          properties.value.value = f;
        } else {
          if (context.length >= 2) {
            const ctx = context[context.length - 2];

            if (ctx.value[value] !== undefined) {
              properties.value.value = ctx.value[value];
              return;
            }
          }
          if (context[0].value.properties) {
            const v = context[0].value.properties[value];
            if (v !== undefined) {
              properties.value.value = v;
              return;
            }
          }

          const c = constants[value];
          if (c) {
            properties.value.value = c;
          }
        }
      },
      prefix: {
        '(': {
          precedence: 80,
          led(grammar, left) {
            if (left.type === 'function') {
              const args = [];

              if (grammar.token.value !== ')') {
                while (true) {
                  args.push(grammar.expression(0));

                  if (grammar.token.value !== ',') {
                    break;
                  }
                  grammar.advance(',');
                }
              }

              grammar.advance(')');

              return left.value(args);
            } else {
              const e = grammar.expression(0);
              grammar.advance(')');
              return e;
            }
          }
        }
      },
      infix: {
        ',': {},
        ')': {},
        '+': {
          precedence: 50,
          combine: (left, right) => {
            if (parseFloat(left.value) === left.value) {
              return createValue(left.value + parseFloat(right.value));
            }

            return createValue(left.value + right.value);
          }
        },
        '-': {
          precedence: 50,
          combine: (left, right) => createValue(left.value - right.value)
        },
        '*': {
          precedence: 60,
          combine: (left, right) => createValue(left.value * right.value)
        },
        '/': {
          precedence: 60,
          combine: (left, right) => createValue(left.value / right.value)
        }
      }
  });

  const ctx = ee.createContext({
    evaluate: (expression, context, path) => {
      /*
      if (path.length >= 4 && path[1].key === 'services') {
        const serviceName = path[2].value.name;
        const attributeName = path.slice(3).reduce((p, c) => p + (Number.isInteger(c.key) ? `[${c.key}]` : p ?
          '.' + c.key : c.key), '');
        console.log(`${path[2].value.name}.${attributeName} = ${expression}`);
      }
      */
      const v = g.parse(expression, path).value;
      return v;
    }
  });

  return ctx.expand(config);
}

#!/usr/bin/env node

/* jslint node: true, esnext: true */

'use strict';

const os = require('os'),
  fs = require('fs'),
  path = require('path'),
  commander = require('commander'),
  ksm = require('kronos-service-manager'),
  ee = require('expression-expander'),
  systemdSocket = require('systemd-socket'),
  rebirth = require('rebirth'),
  glob = require('glob');

require('pkginfo')(module, 'version');

let logLevel = 'info';

const flowFileNames = [];
const values = [];

commander
  .version(module.exports.version)
  .description('run cluster node')
  .option('-f, --flow <file>', 'flow to be registered', name => flowFileNames.push(name))
  .option('-s, --start', 'start flow after registering')
  .option('-c, --config <file>', 'use config from file')
  .option('-d, --define <service:key=value>', 'define service value', value => values.push(value))
  .option('-d, --debug', 'enable debugging')
  .option('-t, --trace', 'enable tracing')
  .parse(process.argv);

if (commander.debug) {
  logLevel = 'debug';
} else if (commander.trace) {
  logLevel = 'trace';
}

const cfg = commander.config ? new Promise((fullfill, reject) => {
  fs.readFile(commander.config, (err, data) => {
    if (err) reject(err);
    else {
      const ctx = ee.createContext({
        evaluate: (expression, context) => {
          let r = expression.match(/file\(\s*\'([^\']+)\'\s*\)/);
          if (r) {
            return fs.readFileSync(path.resolve(path.dirname(commander.config), r[1]));
          }

          r = expression.match(/directory\(\s*\'([^\']+)\'\s*\)/);
          if (r) {
            return path.resolve(path.dirname(commander.config), r[1]);
          }

          return undefined;
        }
      });
      fullfill(ctx.expand(JSON.parse(data)));
    }
  });
}) : Promise.resolve([{
  name: 'kronos'
}, {
  name: 'koa-admin',
  port: 10000
}, {
  name: 'registry', // consul
  checkInterval: '60s'
}]);

process.on('SIGHUP', () => rebirth());

function pglob(path, options) {
  return new Promise((fullfull, reject) => {
    glob(path, options, (err, files) => {
      if (err) {
        reject(err);
      } else {
        fullfull(files);
      }
    });
  });
}

function kronosModules() {
  return pglob(path.join(__dirname, '..', 'node_modules/*/package.json'), {}).then(files => {
    const modules = [];
    return Promise.all(files.map(file =>
      new Promise((fullfill, reject) => {
        fs.readFile(file, (err, data) => {
          if (err) {
            reject(`loading ${file}: ${err}`);
            return;
          }
          try {
            const p = JSON.parse(data);

            if (p.keywords) {
              if (p.keywords.find(k => k === 'kronos-step' || k ===
                  'kronos-service' || k ===
                  'kronos-interceptor')) {
                try {
                  modules.push(require(p.name));
                  fullfill();
                  return;
                } catch (e) {
                  reject(`${file}: ${p.name} ${e}`);
                }
              }
            }
          } catch (e) {
            reject(e);
          }

          fullfill();
        });
      })
    )).then(results => modules);
  });
}

Promise.all([kronosModules(), cfg]).then(results => {
  const modules = results[0];
  const cfg = results[1];

  values.forEach(value => {
    const m = value.match(/^([^:]+):([^=]+)=(.*)/);
    if (m) {
      let slot = cfg.find(c => c.name === m[1]);
      if (slot) {
        slot[m[2]] = m[3];
      } else {
        cfg.push({
          name: m[1],
          [m[2]]: m[3]
        });
      }
    } else {
      console.log(`no service:key=value ${value}`);
    }
  });

  cfg.forEach(c => c.logLevel = logLevel);

  const sds = systemdSocket();
  if (sds) {
    cfg[1 /* TODO admin */ ].port = sds;
  }

  ksm.manager(cfg, modules).then(manager => {
    process.on('uncaughtException', err => manager.error(err));
    process.on('unhandledRejection', reason => manager.error(reason));
    process.on('SIGINT', () => manager.stop().then(() => process.exit()));

    flowFileNames.forEach(name => {
      manager.loadFlowFromFile(name).then(flow => {
        manager.info(level => `Flow declared: ${flow}`);
        if (commander.start) {
          manager.info(level => `Starting ... ${flow}`);
          flow.start().then(() => manager.info(`Flow started: ${flow}`)).catch(error =>
            manager.error(
              `Flow started failed: ${error}`));
        }
      }).catch(error => manager.error(`Flow initialization failed: ${error}`));
    });
  });
}).catch(console.log);

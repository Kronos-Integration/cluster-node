#!/usr/bin/env node

/* jslint node: true, esnext: true */

"use strict";

const os = require('os'),
  fs = require('fs'),
  path = require('path'),
  pkginfo = require('pkginfo')(module, 'name', 'version'),
  commander = require('commander'),
  ksm = require('kronos-service-manager'),
  systemdSocket = require('systemd-socket'),
  rebirth = require('rebirth'),
  list_files = require('list_files').list_files;


Error.prepareStackTrace = (err, stackObj) => stackObj[0];

let logLevel = "trace";

const config = {
  "kronos": {
    "logLevel": logLevel
  },
  "consul": {
    "logLevel": logLevel
  },
  "admin": {
    "logLevel": logLevel,
    "port": 10000
  },
  "health-check": {
    "logLevel": logLevel,
    "port": 9999
  }
};

commander
  .version(module.exports.version)
  .description('run cluster node')
  //  .option('-ar, --autoregister', 'load and register all installed kronos moudles')
  .option('-n, --nodename <name>', 'kronos node name defaults to hostname')
  .option('-f, --flow <file>', 'specify flow definition to be registered')
  .option('-s, --start', 'also start flow after registering')
  .option('-d, --debug', 'enable debugging')
  .option('-d, --dataCenter <dataCenter>', 'specify consul data center')
  .option('-p, --port <portNumber>', `specify kronos http port (default is ${config.admin.port})`)
  .parse(process.argv);

if (commander.debug) {
  logLevel = 'debug';
}

//kronosOptions.name = commander.nodename ? commander.nodename : os.hostname();

if (commander.dataCenter) {
  config.consul.dataCenter = commander.dataCenter;
}

if (commander.port) {
  config.admin.port = commander.port;
} else {
  config.admin.port = systemdSocket();
}

process.on('SIGHUP', () => rebirth());

ksm.manager(config /*, [require('kronos-koa-service'), require('kronos-health-check-service')]*/ ).then(manager => {
    try {
      const baseDir = path.join(__dirname, '..', 'node_modules');

      list_files(baseDir, '', 'package.json', (error, file, stat) => {
        const f = path.join(baseDir, file);
        fs.readFile(f, function (err, data) {
          if (err) {
            manager.error(`loading ${f}: ${e}`);
            return;
          }
          try {
            const p = JSON.parse(data);

            if (p.keywords) {
              if (p.keywords.indexOf('kronos-step') >= 0 ||
                p.keywords.indexOf('kronos-service') >= 0 ||
                p.keywords.indexOf('kronos-interceptor') >= 0) {
                try {
                  require(p.name).registerWithManager(manager);
                  manager.info(level => `${p.name} registered`);
                } catch (e) {
                  manager.error(`${f}: ${p.name} ${e}`);
                }
              }
            }
          } catch (e) {
            manager.error(`${f}: ${e}`);
          }
        });
      }, () => {
        Object.keys(manager.services).forEach(name => {
          const s = manager.services[name];
          manager.info(level => ({
            'service-name': name,
            'state': s.state,
            'logLevel': s.logLevel
          }));
        });

        if (commander.flow) {
          manager.loadFlowFromFile(commander.flow).then(flow => {
            manager.info(level => `Flow declared: ${flow}`);
            if (commander.start) {
              manager.info(level => `Starting ... ${flow}`);
              flow.start().then(() => manager.info(`Flow started: ${flow}`)).catch(error => manager.error(
                `Flow started failed: ${error}`));
            }
          }).catch(error => manager.error(`Flow initialization failed: ${error}`));
        }
      });

    } catch (e) {
      console.log(e);
      manager.error(e);
    }

    return manager;
  },
  err => manager.error(`manager failed: ${err}`));
